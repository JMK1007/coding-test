# 문제 링크

[광물 캐기](https://school.programmers.co.kr/learn/courses/30/lessons/172927)

# 1. 내 풀이

```js
function solution(picks, minerals) {
  let answer = Infinity;
  const rank = {
    diamond: 0,
    iron: 1,
    stone: 2,
  };

  function dfs(picks, minerals, fatigue) {
    // 도구가 없거나 광물이 없을때 return
    if (picks.reduce((acc, curr) => acc + curr, 0) === 0 || !minerals.length) {
      answer = Math.min(answer, fatigue);
      return;
    }

    // 도구별 피로도 계산
    for (let i = 0; i < picks.length; i++) {
      let newFatigue = fatigue;
      const currPickCount = picks[i];
      const currPickRank = i;
      // 도구가 없을땐 다음 도구로 스킵
      if (!currPickCount) {
        continue;
      }
      // 도구가 있다
      const newPicks = [...picks];
      newPicks[i] -= 1; // 도구 삭제
      const newMinerals = minerals.length <= 5 ? [] : [...minerals].splice(5); // 캐고 남은 광물

      // 피로도계산
      for (let i = 0; i < (minerals.length >= 5 ? 5 : minerals.length); i++) {
        const currMineralRank = rank[minerals[i]]; // 현재 캘 광물의 랭킹
        if (currPickRank <= currMineralRank) {
          newFatigue += 1;
        } else {
          newFatigue += Math.pow(5, currPickRank - currMineralRank);
        }
      }
      dfs(newPicks, newMinerals, newFatigue);
    }
  }
  dfs(picks, minerals, 0);
  return answer;
}
```

## 풀이 방법

### 문제요점

- 다이아몬드, 철, 돌 0-5개
- 곡갱이는 5개를 연속으로 캔 후 사용할 수 없다.
- 최소한의 피로도
- 모든 광물을 캐거나, 남은 곡갱이가 없을 때까지 광물을 캔다

### 풀이

- 각 도구마다 각 광물을 캘 떄 모든 경우를 완전탐색하며 최소 피로도를 구했다.
- dfs(남은도구, 남은광물, 피로도)
- dfs반복 끝내는 조건: 남은도구가 없거나 남은 광물이 없을시 피로도를 갱신한다.
- picks를 순회하며 존재하는 도구를 사용할 경우 남은 도구, 남은광물, 누적피로도를 계산하여 dfs한다.

# 2. 느낀 점

# 3. 배운 점

- 다양한 경우가 있을 시 완전탐색을 사용할 수 있다.
- object를 사용하여 두 광물의 diff계산을 쉽게 할 수 있다.
